#!/usr/bin/env bash
#
# BaoFactory management script - extract bytecode, deploy, or verify
#
# Usage:
#   bao-factory --extract                                    # Compile and save bytecode + artifacts
#   bao-factory --deploy --network mainnet --account X       # Deploy using saved artifacts
#   bao-factory --predict --salt X                           # Show predicted addresses for a salt
#
# The script:
# 1. --extract: Compiles in isolated environment, saves bytecode/.json/build/ artifacts
# 2. --deploy: Uses saved artifacts to deploy (no recompilation)
#

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"

# Output files and directories
BYTECODE_SOL="$PROJECT_ROOT/src/BaoFactoryBytecode.sol"

# Nick's Factory address (same on all EVM chains)
NICKS_FACTORY="0x4e59b44847b379578588920cA78FbF26c0B4956C"

# Production defaults
OWNER="0x9bABfC1A1952a6ed2caC1922BFfE80c0506364a2"
SALT="Bao.BaoFactory.harbor"

# Deterministic compiler settings - SINGLE SOURCE OF TRUTH
SOLC_VERSION="0.8.30"
EVM_VERSION="prague"
OPTIMIZER_RUNS="10000"

# Default anvil private key (account 0)
ANVIL_PRIVATE_KEY="0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80"

# ============================================================================
# HELPER FUNCTIONS
# ============================================================================

usage() {
  cat <<EOF
Usage: bao-factory <--extract | --deploy | --verify | --predict | --status | --implementation> [OPTIONS]

BaoFactory bytecode extraction, deployment, and verification

Modes (exactly one required):
  --extract             Compile and save bytecode + build artifacts
  --deploy              Deploy BaoFactory using saved artifacts
  --predict             Show predicted addresses for a salt
  --status              Show deployment status (JSON output)
  --implementation <contract>  Deploy implementation and print upgrade instructions

Options:
  --network <name>      Network name (required for --deploy, --implementation)
  --salt <string>       Salt string (default: $SALT)
  --account <name>      Foundry keystore account (required for non-local networks)
  --etherscan <key>     Etherscan API key (required for --implementation on non-local;
                        optional for --status; disallowed on local network)

General options:
  -h, --help            Show this help message

Wallet (for --deploy):
  For local network: uses first Anvil account unless --account specified
  For other networks: --account is required

Examples:
  # Extract bytecode after modifying BaoFactory.sol
  bao-factory --extract

  # Deploy to mainnet with default salt
  bao-factory --deploy --network mainnet --account deployer

  # Deploy to local with custom salt
  bao-factory --deploy --network local --salt Bao.Test.v1

  # Predict addresses for a custom salt
  bao-factory --predict --salt Bao.MyFactory.v1

  # Deploy an implementation and get upgrade instructions
  bao-factory --implementation src/BaoFactory_v1.sol:BaoFactory_v1 --network mainnet --account deployer

EOF
  exit "${1:-0}"
}

error() {
  echo "ERROR: $*" >&2
  exit 1
}

log() {
  echo "==> $*"
}

# Get bytecode from saved BaoFactoryBytecode.sol
get_saved_bytecode() {
  if [[ ! -f "$BYTECODE_SOL" ]]; then
    error "BaoFactoryBytecode.sol not found. Run 'bao-factory --extract' first."
  fi

  local bytecode
  bytecode=$(grep -A1 "bytes internal constant CREATION_CODE =" "$BYTECODE_SOL" |
    grep -oP 'hex"[^"]*"' | sed 's/hex"//g' | sed 's/"//g' | tr -d '\n')

  if [[ -z "$bytecode" ]]; then
    error "Could not extract bytecode from BaoFactoryBytecode.sol"
  fi

  echo "0x$bytecode"
}

# Get salt bytes32 from global SALT
get_salt_bytes() {
  cast keccak "$(cast --from-utf8 "$SALT")" | sed 's/0x//'
}

# Predict CREATE2 address from Nick's Factory for given bytecode
predict_create2_address() {
  local bytecode="$1"
  local salt_bytes
  salt_bytes=$(get_salt_bytes)

  local init_code_hash
  init_code_hash=$(cast keccak "$bytecode")

  # CREATE2: keccak256(0xff ++ factory ++ salt ++ keccak256(init_code))[12:]
  local packed="0xff${NICKS_FACTORY#0x}${salt_bytes}${init_code_hash#0x}"
  local hash
  hash=$(cast keccak "$packed")

  cast to-check-sum-address "0x${hash:26}"
}

# Get implementation address from saved bytecode via CREATE2
get_impl_address() {
  local bytecode
  bytecode=$(get_saved_bytecode)
  predict_create2_address "$bytecode"
}

# Predict CREATE address with nonce=1 from given deployer address
predict_create_address() {
  local deployer="$1"

  # CREATE (nonce=1): keccak256(RLP([sender, 1]))[12:]
  # RLP([20-byte-addr, 1]) = 0xd694 ++ addr ++ 01
  local packed="0xd694${deployer#0x}01"
  local hash
  hash=$(cast keccak "$packed")

  cast to-check-sum-address "0x${hash:26}"
}

# Get proxy address from implementation (which deploys proxy at nonce=1)
get_proxy_address() {
  local impl_address
  impl_address=$(get_impl_address)
  predict_create_address "$impl_address"
}

# ============================================================================
# EXTRACT MODE
# ============================================================================

do_extract() {
  log "BaoFactory Bytecode Extraction"
  log "=============================="
  local salt="$SALT"
  cat <<EOF
  Source:  src/BaoFactory.sol
  Output:  $BYTECODE_SOL
  Salt:    $salt

EOF

  log "Compiling..."
  local artifact="$PROJECT_ROOT/out/BaoFactory.sol/BaoFactory.json"
  forge build --force src/BaoFactory.sol 2>&1 | sed 's/^/    /'

  # Extract bytecode

  if [[ ! -f "$artifact" ]]; then
    error "Compilation failed - artifact not found"
  fi

  local bytecode
  bytecode=$(jq -r '.bytecode.object' "$artifact")
  if [[ -z "$bytecode" || "$bytecode" == "null" ]]; then
    error "Failed to extract bytecode from artifact"
  fi

  local bytecode_hex="${bytecode#0x}"
  local bytecode_hash
  bytecode_hash=$(cast keccak "$bytecode")

  echo ""
  log "Extracted bytecode:"
  echo "    Size: $((${#bytecode_hex} / 2)) bytes"
  echo "    Hash: $bytecode_hash"

  # Compute addresses for default salt
  local impl_address proxy_address
  impl_address=$(predict_create2_address "$bytecode")
  proxy_address=$(predict_create_address "$impl_address")

  # Generate BaoFactoryBytecode.sol
  mkdir -p "$(dirname "$BYTECODE_SOL")"
  cat >"$BYTECODE_SOL" <<SOLEOF
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.28 <0.9.0;

// ============================================================================
// AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
// ============================================================================
// Compiler: solc $SOLC_VERSION
// EVM version: $EVM_VERSION
// Optimizer: true (runs: $OPTIMIZER_RUNS, via_ir: true)
// Metadata: none (bytecode_hash = "none", cbor_metadata = false)
// ============================================================================
//
// This file contains the captured creation code for BaoFactory.
// To regenerate: ./script/bao-factory --extract
//
// For deployment logic, see BaoFactoryDeployLib.sol
// For Foundry test utilities, see BaoFactoryFoundryLib.sol
// ============================================================================

/// @title BaoFactoryBytecode
/// @author Bao Finance
/// @notice Captured creation code and addresses for deterministic BaoFactory deployment
/// @dev Generated bytecode ensures consistent addresses regardless of compiler changes
library BaoFactoryBytecode {

    /// @dev BaoFactory salt string
    string internal constant SALT = "$salt";

    /// @dev BaoFactory owner (Harbor multisig)
    address internal constant OWNER = $OWNER;

    /// @dev BaoFactory creation code
    // slither-disable-next-line too-many-digits
    bytes internal constant CREATION_CODE =
        hex"$bytecode_hex";

    /// @dev keccak256 of CREATION_CODE
    bytes32 internal constant CREATION_CODE_HASH = $bytecode_hash;

    /// @dev Predicted implementation address (depends on SALT and CREATION_CODE_HASH)
    address internal constant PREDICTED_IMPLEMENTATION = $impl_address;

    /// @dev Predicted proxy address (depends on PREDICTED_IMPLEMENTATION)
    address internal constant PREDICTED_PROXY = $proxy_address;
}
SOLEOF

  log "Generated $BYTECODE_SOL"
  cat <<EOF

  Predicted addresses for salt '$salt':
    Implementation: $impl_address
    Proxy:          $proxy_address

  Done!
EOF
}
# ============================================================================

do_deploy() {
  local account="$1"
  local etherscan_key="${2:-}"

  log "BaoFactory Deployment"
  log "====================="

  # Get saved bytecode for display
  local bytecode
  bytecode=$(get_saved_bytecode)
  local bytecode_hash
  bytecode_hash=$(cast keccak "$bytecode")

  echo "  Bytecode hash: $bytecode_hash"
  echo "  Bytecode size: $(((${#bytecode} - 2) / 2)) bytes"
  echo ""

  # Compute addresses for this salt
  local salt_bytes impl_address proxy_address
  salt_bytes=$(get_salt_bytes)
  impl_address=$(get_impl_address)
  proxy_address=$(get_proxy_address)

  cat <<EOF
  Salt:           $SALT
  Salt bytes32:   0x$salt_bytes
  Network:        $NETWORK
  Owner:          $OWNER

EOF

  log "Predicted addresses:"
  echo "  Implementation: $impl_address"
  echo "  Proxy:          $proxy_address"
  echo ""

  # Set up wallet
  local wallet_args=""
  if [[ "$NETWORK" == "local" ]]; then
    if [[ -n "$account" ]]; then
      wallet_args="--account $account"
    else
      wallet_args="--private-key $ANVIL_PRIVATE_KEY"
    fi
  else
    if [[ -z "$account" ]]; then
      error "--account is required for non-local networks"
    fi
    wallet_args="--account $account"
  fi

  # Check if already deployed
  local impl_code
  impl_code=$(cast code "$impl_address" --rpc-url "$NETWORK" 2>/dev/null || echo "0x")
  if [[ "$impl_code" != "0x" && "$impl_code" != "" ]]; then
    error "Already deployed at $impl_address"
  fi

  # Deploy via Nick's Factory
  log "Deploying via Nick's Factory..."

  local deploy_data="0x${salt_bytes}${bytecode#0x}"
  local tx_hash
  tx_hash=$(cast send --json --rpc-url "$NETWORK" $wallet_args \
    "$NICKS_FACTORY" "$deploy_data" | jq -r '.transactionHash')

  if [[ -z "$tx_hash" || "$tx_hash" == "null" ]]; then
    error "Deployment transaction failed"
  fi

  log "Transaction submitted: $tx_hash"

  log "Waiting for confirmation..."
  cast receipt --rpc-url "$NETWORK" "$tx_hash" >/dev/null

  # Verify deployment
  impl_code=$(cast code "$impl_address" --rpc-url "$NETWORK")
  if [[ "$impl_code" == "0x" || "$impl_code" == "" ]]; then
    error "Implementation deployment failed - no code at $impl_address"
  fi

  local proxy_code
  proxy_code=$(cast code "$proxy_address" --rpc-url "$NETWORK")
  if [[ "$proxy_code" == "0x" || "$proxy_code" == "" ]]; then
    error "Proxy deployment failed - no code at $proxy_address"
  fi

  log "Deployment successful!"

  # Verify on Etherscan if key provided
  if [[ -n "$etherscan_key" ]]; then
    local chain_id
    chain_id=$(cast chain-id --rpc-url "$NETWORK")

    log "Verifying implementation on Etherscan..."
    forge verify-contract \
      --chain-id "$chain_id" \
      --etherscan-api-key "$etherscan_key" \
      --watch \
      --root "$PROJECT_ROOT" \
      --compiler-version "$SOLC_VERSION" \
      --optimizer-runs "$OPTIMIZER_RUNS" \
      --via-ir \
      "$impl_address" \
      "src/BaoFactory.sol:BaoFactory" || echo "Warning: Verification failed (can retry manually)"
  fi

  cat <<EOF

  BaoFactory deployed:
    Proxy (use this):     $proxy_address
    Implementation:       $impl_address
    Owner:                $OWNER
    Transaction:          $tx_hash
EOF
}

# ============================================================================
# PREDICT MODE
# ============================================================================

do_predict() {
  log "BaoFactory Address Prediction"
  log "============================="

  # Compute addresses
  local salt_bytes impl_address proxy_address
  salt_bytes=$(get_salt_bytes)
  impl_address=$(get_impl_address)
  proxy_address=$(get_proxy_address)

  cat <<EOF

  Salt:           $SALT
  Salt (bytes32): 0x$salt_bytes

  Predicted addresses:
    Implementation: $impl_address
    Proxy:          $proxy_address
EOF
}

# ============================================================================
# STATUS MODE
# ============================================================================

do_status() {
  local etherscan_key="${1:-}"

  # Get current block info
  local block_number
  block_number=$(cast block-number --rpc-url "$NETWORK" 2>/dev/null || echo "0")
  local block_timestamp
  block_timestamp=$(cast block "$block_number" --field timestamp --rpc-url "$NETWORK" 2>/dev/null || echo "0")
  local block_time
  block_time=$(date -d "@$block_timestamp" '+%Y-%m-%d %H:%M:%S UTC' 2>/dev/null || date -r "$block_timestamp" '+%Y-%m-%d %H:%M:%S UTC' 2>/dev/null || echo "unknown")

  # Get proxy address
  local bootstrap_impl proxy_address
  bootstrap_impl=$(get_impl_address)
  proxy_address=$(get_proxy_address)

  # Check if deployed
  local proxy_code
  proxy_code=$(cast code "$proxy_address" --rpc-url "$NETWORK" 2>/dev/null || echo "0x")

  if [[ "$proxy_code" == "0x" || -z "$proxy_code" ]]; then
    # Not deployed
    cat <<EOF
{
  "status": "not_deployed",
  "proxy": "$proxy_address",
  "bootstrapImplementation": "$bootstrap_impl",
  "salt": "$SALT",
  "block": $block_number,
  "timestamp": "$block_time"
}
EOF
    return
  fi

  # Get the actual current implementation from proxy
  local current_impl
  current_impl=$(cast implementation "$proxy_address" --rpc-url "$NETWORK" 2>/dev/null || echo "unknown")

  # Check if it's still bootstrap by comparing implementation to predicted bootstrap address
  # Use case-insensitive comparison since cast returns lowercase but we predict checksummed
  local status="bootstrap"
  if [[ "${current_impl,,}" != "${bootstrap_impl,,}" ]]; then
    status="upgraded"
  fi

  # Get implementation contract details from Etherscan (requires --etherscan <key>)
  local impl_file="" impl_name="" impl_args="" impl_compiler="" impl_runs=""
  if [[ -n "$etherscan_key" && "$current_impl" != "unknown" ]]; then
    local etherscan_response
    etherscan_response=$(curl -s "https://api.etherscan.io/v2/api?chainid=1&module=contract&action=getsourcecode&address=$current_impl&apikey=$etherscan_key" 2>/dev/null || echo "{}")
    local result
    result=$(echo "$etherscan_response" | jq -r '.result[0] // empty' 2>/dev/null || echo "")
    if [[ -n "$result" ]]; then
      impl_file=$(echo "$result" | jq -r '.SourceCode | if type == "object" then (keys[0] // "") else "" end' 2>/dev/null || echo "")
      # If SourceCode is a string (flattened), try to get filename from ContractName
      if [[ -z "$impl_file" ]]; then
        impl_file=$(echo "$result" | jq -r '.ContractName // ""' 2>/dev/null || echo "")
        [[ -n "$impl_file" ]] && impl_file="${impl_file}.sol"
      fi
      impl_name=$(echo "$result" | jq -r '.ContractName // ""' 2>/dev/null || echo "")
      impl_args=$(echo "$result" | jq -r '.ConstructorArguments // ""' 2>/dev/null || echo "")
      impl_compiler=$(echo "$result" | jq -r '.CompilerVersion // ""' 2>/dev/null || echo "")
      impl_runs=$(echo "$result" | jq -r '.Runs // ""' 2>/dev/null || echo "")
    fi
  fi

  # Get owner
  local owner
  owner=$(cast call "$proxy_address" "owner()(address)" --rpc-url "$NETWORK" 2>/dev/null || echo "unknown")

  # Get operators by enumerating via operatorAt() until revert (only for upgraded status)
  local operators_json=""
  if [[ "$status" == "upgraded" ]]; then
    local operators="["
    local op_index=0
    local first_op=true
    while true; do
      local op_result
      # Temporarily disable errexit to catch revert without script exit
      set +e
      op_result=$(cast call "$proxy_address" "operatorAt(uint256)(address,uint256)" "$op_index" --rpc-url "$NETWORK" 2>/dev/null)
      local cast_status=$?
      set -e
      if [[ $cast_status -ne 0 ]]; then
        break
      fi

      # Parse address and expiry from result (two lines)
      # Note: cast outputs numbers with annotation like "1766379175 [1.766e9]" - strip the annotation
      local op_addr op_expiry_raw op_expiry
      op_addr=$(echo "$op_result" | head -1)
      op_expiry_raw=$(echo "$op_result" | tail -1)
      op_expiry=$(echo "$op_expiry_raw" | awk '{print $1}')

      # Check if we got valid data
      if [[ -z "$op_addr" || "$op_addr" == "0x0000000000000000000000000000000000000000" ]]; then
        break
      fi

      # Format expiry as human-readable date
      local expiry_date
      expiry_date=$(date -d "@$op_expiry" '+%Y-%m-%d %H:%M:%S UTC' 2>/dev/null || date -r "$op_expiry" '+%Y-%m-%d %H:%M:%S UTC' 2>/dev/null || echo "unknown")

      # Check if active (not expired)
      local is_active="false"
      if [[ "$op_expiry" -gt "$block_timestamp" ]]; then
        is_active="true"
      fi

      # Add comma separator if not first
      if [[ "$first_op" == "true" ]]; then
        first_op=false
      else
        operators+=","
      fi

      operators+="{\"address\":\"$op_addr\",\"expiry\":$op_expiry,\"expiryDate\":\"$expiry_date\",\"active\":$is_active}"
      op_index=$((op_index + 1))
    done
    operators+="]"
    operators_json="\"operators\": $operators,"
  else
    operators_json="\"operators\": \"not supported - upgrade the proxy\","
  fi

  # Build implementation object conditionally
  local impl_json
  if [[ -n "$etherscan_key" ]]; then
    impl_json=$(
      cat <<IMPL
"implementation": {
    "address": "$current_impl",
    "file": "$impl_file",
    "name": "$impl_name",
    "constructorArgs": "$impl_args",
    "compiler": "$impl_compiler",
    "runs": "$impl_runs"
  }
IMPL
    )
  else
    impl_json='"implementation": "'"$current_impl"'"'
  fi

  cat <<EOF
{
  "status": "$status",
  "proxy": "$proxy_address",
  $impl_json,
  "bootstrapImplementation": "$bootstrap_impl",
  "owner": "$owner",
  "salt": "$SALT",
  $operators_json
  "block": $block_number,
  "timestamp": "$block_time"
}
EOF
}

# ============================================================================
# IMPLEMENTATION MODE
# ============================================================================

do_implementation() {
  local account="$1"
  local contract="$2"
  local etherscan_key="${3:-}"

  log "BaoFactory Implementation Deployment"
  log "===================================="

  if [[ -z "$contract" ]]; then
    error "Contract source is required for --implementation"
  fi

  # Get proxy address
  local impl_address proxy_address
  impl_address=$(get_impl_address)
  proxy_address=$(get_proxy_address)

  cat <<EOF
  Contract:  $contract
  Network:   $NETWORK
  Proxy:     $proxy_address

EOF

  # Set up wallet
  local wallet_args=""
  if [[ "$NETWORK" == "local" ]]; then
    if [[ -n "$account" ]]; then
      wallet_args="--account $account"
    else
      wallet_args="--private-key $ANVIL_PRIVATE_KEY"
    fi
  else
    if [[ -z "$account" ]]; then
      error "--account is required for non-local networks"
    fi
    wallet_args="--account $account"
  fi

  local chain_id
  chain_id=$(cast chain-id --rpc-url "$NETWORK")

  log "Deploying $contract..."

  local forge_output
  forge_output=$(forge create --rpc-url "$NETWORK" $wallet_args --broadcast --json "$contract") || error "forge create failed"

  # Extract deployed address from JSON output
  local new_impl
  new_impl=$(echo "$forge_output" | jq -r '.deployedTo') || error "Failed to parse deployment address"

  log "Implementation deployed at: $new_impl"

  # Verify on Etherscan if key provided
  if [[ -n "$etherscan_key" ]]; then
    log "Verifying on Etherscan..."
    forge verify-contract \
      --chain-id "$chain_id" \
      --etherscan-api-key "$etherscan_key" \
      --watch \
      "$new_impl" \
      "$contract" || echo "Warning: Verification failed (can retry manually)"
  fi

  cat <<EOF

============================================================================
NEXT STEPS
============================================================================

1. Upgrade the Bao factory proxy to the new implementation:

   a. get the ABI fom https://etherscan.io/address/$proxy_address#code

   b. go to https://app.safe.global/apps/open?safe=eth:0x9bABfC1A1952a6ed2caC1922BFfE80c0506364a2&appUrl=https%3A%2F%2Fapps-portal.safe.global%2Ftx-builder

      Address or ENS Name:         $proxy_address
      ABI:                         (paste ABI from step 1a)
      ETH value:                   0
      newImplementation (addtrss): $new_impl
      data (bytes):                0x

      + Add new transaction

   d. get it signed and executed

      on local networks this is equivalent to:
      $ cast send $proxy_address 'upgradeTo(address)' $new_impl

   e. check the new implementation is in place:

      $ cast implementation $proxy_address --rpc-url $NETWORK
      $new_impl
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ should be the implementation address as shown

2. On BaoFactory_v1 for an address, not the multisig, use use deploy functions they need to be made an operator:

   a. get the ABI fom https://etherscan.io/address/$new_impl#code

   b. go to https://app.safe.global/apps/open?safe=eth:0x9bABfC1A1952a6ed2caC1922BFfE80c0506364a2&appUrl=https%3A%2F%2Fapps-portal.safe.global%2Ftx-builder

      Address or ENS Name:         $proxy_address
      ABI:                         (paste ABI from step 2a)
      Contract <ethod Selector:    setOperator
      operator_ (address):         (operator address)
      duration_ (uint256):         (duration in seconds - e.g., 86400 for 1 day, 604800 for 1 week, etc.)

      + Add new transaction

   d. get it signed and executed

      on local networks this is equivalent to:
      $ cast send $proxy_address 'setOperator(address,uint256)' <operator address> <duration in seconds>

      you can check the operators by:
      $ script/bao-factory --status --network $NETWORK

      which is equivalent to:
      $ cast call $proxy_address --rpc-url $NETWORK 'operatorAt(uint256)(address,uint256)' <index>

      if that reverts you have reached the end of the operators list

============================================================================
EOF
}

# ============================================================================
# MAIN
# ============================================================================

# Parse arguments
MODE=""
NETWORK=""
SALT_ARG=""
ACCOUNT=""
IMPLEMENTATION_CONTRACT=""
ETHERSCAN_KEY=""

while [[ $# -gt 0 ]]; do
  case "$1" in
    --extract)
      MODE="extract"
      shift
      ;;
    --predict)
      MODE="predict"
      shift
      ;;
    --deploy)
      MODE="deploy"
      shift
      ;;
    --status)
      MODE="status"
      shift
      ;;
    --implementation)
      MODE="implementation"
      IMPLEMENTATION_CONTRACT="$2"
      shift 2
      ;;
    --network)
      NETWORK="$2"
      shift 2
      ;;
    --salt)
      SALT="$2"
      SALT_ARG="$2"
      shift 2
      ;;
    --account)
      ACCOUNT="$2"
      shift 2
      ;;
    --etherscan)
      ETHERSCAN_KEY="$2"
      shift 2
      ;;
    -h | --help)
      usage 0
      ;;
    *)
      error "Unknown option: $1"
      ;;
  esac
done

# Validate mode
if [[ -z "$MODE" ]]; then
  error "Must specify --extract, --deploy, --predict, --status, or --implementation"
fi

cd "$PROJECT_ROOT"

case "$MODE" in
  extract)
    if [[ -n "$SALT_ARG" ]]; then
      error "--salt cannot be used with --extract. Use '--predict --salt <value>' to inspect custom salts."
    fi
    do_extract
    ;;
  deploy)
    if [[ -z "$NETWORK" ]]; then
      error "--network is required for --deploy"
    fi
    if [[ "$NETWORK" == "local" && -n "$ETHERSCAN_KEY" ]]; then
      error "--etherscan is not supported on local network"
    fi
    if [[ "$NETWORK" != "local" && -z "$ETHERSCAN_KEY" ]]; then
      error "--etherscan is required for --deploy on non-local networks"
    fi
    do_deploy "$ACCOUNT" "$ETHERSCAN_KEY"
    ;;
  predict)
    do_predict
    ;;
  status)
    if [[ -z "$NETWORK" ]]; then
      NETWORK="local"
    fi
    if [[ "$NETWORK" == "local" && -n "$ETHERSCAN_KEY" ]]; then
      error "--etherscan is not supported on local network"
    fi
    do_status "$ETHERSCAN_KEY"
    ;;
  implementation)
    if [[ -z "$NETWORK" ]]; then
      error "--network is required for --implementation"
    fi
    if [[ "$NETWORK" == "local" && -n "$ETHERSCAN_KEY" ]]; then
      error "--etherscan is not supported on local network"
    fi
    if [[ "$NETWORK" != "local" && -z "$ETHERSCAN_KEY" ]]; then
      error "--etherscan is required for --implementation on non-local networks"
    fi
    do_implementation "$ACCOUNT" "$IMPLEMENTATION_CONTRACT" "$ETHERSCAN_KEY"
    ;;
esac
