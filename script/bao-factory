#!/usr/bin/env bash
#
# BaoFactory management script - extract bytecode, deploy, or verify
#
# Usage:
#   bao-factory --extract                                    # Compile and save bytecode + artifacts
#   bao-factory --deploy --network mainnet --account X       # Deploy using saved artifacts
#   bao-factory --verify --network mainnet                   # Verify on Etherscan
#   bao-factory --predict --salt X                        # Show predicted addresses             Show predicted addresses for a salt
#
# The script:
# 1. --extract: Compiles in isolated environment, saves bytecode/.json/build/ artifacts
# 2. --deploy: Uses saved artifacts to deploy (no recompilation)
# 3. --verify: Verifies on Etherscan using saved artifacts
#

set -euo pipefail

error() {
  echo "ERROR: $*" >&2
  exit 1
}

log() {
  echo "==> $*"
}

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"
log "Running in ${PROJECT_ROOT}"
echo ""

# Output files and directories
BYTECODE_SOL="$PROJECT_ROOT/src/BaoFactoryBytecode.sol"
GAS_TXT="$PROJECT_ROOT/src/gas.txt"

# Nick's Factory address (same on all EVM chains)
NICKS_FACTORY="0x4e59b44847b379578588920cA78FbF26c0B4956C"

# Production defaults
OWNER="0x9bABfC1A1952a6ed2caC1922BFfE80c0506364a2"
DEFAULT_SALT="Bao.BaoFactory.harbor"

# Deterministic compiler settings - SINGLE SOURCE OF TRUTH
SOLC_VERSION="0.8.30"
EVM_VERSION="prague"
OPTIMIZER_RUNS="10000"

# Default anvil private key (account 0)
ANVIL_PRIVATE_KEY="0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80"

# ============================================================================
# HELPER FUNCTIONS
# ============================================================================

usage() {
  cat <<EOF
Usage: bao-factory <--extract | --deploy | --verify | --predict> [OPTIONS]

BaoFactory bytecode extraction, deployment, and verification

Modes (exactly one required):
  --extract             Compile and save bytecode + build artifacts
  --deploy              Deploy BaoFactory using saved artifacts
  --verify              Verify on Etherscan using saved artifacts
  --predict             Show predicted addresses for a salt

Options:
  --network <name>      Network name (required for --deploy and --verify)
  --salt <string>       Salt string (default: $DEFAULT_SALT)
  --account <name>      Foundry keystore account (required for --deploy on non-local networks)
  --dry-run             Show predicted addresses without deploying

General options:
  -h, --help            Show this help message

Wallet (for --deploy):
  For local network: uses first Anvil account unless --account specified
  For other networks: --account is required

Examples:
  # Extract bytecode after modifying BaoFactory.sol
  bao-factory --extract

  # Deploy to mainnet with default salt
  bao-factory --deploy --network mainnet --account deployer

  # Deploy to local with custom salt
  bao-factory --deploy --network local --salt Bao.Test.v1

  # Verify existing deployment on mainnet

  # Predict addresses for a custom salt
  bao-factory --predict --salt Bao.MyFactory.v1
  bao-factory --verify --network mainnet

EOF
  exit "${1:-0}"
}

# Compute CREATE2 address (checksummed)
predict_create2_address() {
  local factory="$1"
  local salt_bytes="$2"
  local init_code="$3"

  local init_code_hash
  init_code_hash=$(cast keccak "$init_code")

  local packed="0xff${factory#0x}${salt_bytes}${init_code_hash#0x}"
  local hash
  hash=$(cast keccak "$packed")

  cast to-check-sum-address "0x${hash:26}"
}

# Compute CREATE address for nonce=1 (checksummed)
predict_create_address_nonce1() {
  local sender="$1"

  local packed="0xd694${sender#0x}01"
  local hash
  hash=$(cast keccak "$packed")

  cast to-check-sum-address "0x${hash:26}"
}

# Get bytecode from saved BaoFactoryBytecode.sol
get_saved_bytecode() {
  if [[ ! -f "$BYTECODE_SOL" ]]; then
    error "BaoFactoryBytecode.sol not found. Run 'bao-factory --extract' first."
  fi

  local bytecode
  bytecode=$(grep -A1 "bytes internal constant CREATION_CODE =" "$BYTECODE_SOL" |
    grep -oP 'hex"[^"]*"' | sed 's/hex"//g' | sed 's/"//g' | tr -d '\n')

  if [[ -z "$bytecode" ]]; then
    error "Could not extract bytecode from BaoFactoryBytecode.sol"
  fi

  echo "0x$bytecode"
}

# Get predicted addresses for a given salt
get_addresses_for_salt() {
  local salt="$1"
  local bytecode="$2"

  local salt_bytes
  salt_bytes=$(cast keccak "$(cast --from-utf8 "$salt")" | sed 's/0x//')

  local impl_address
  impl_address=$(predict_create2_address "$NICKS_FACTORY" "$salt_bytes" "$bytecode")

  local proxy_address
  proxy_address=$(predict_create_address_nonce1 "$impl_address")

  echo "$salt_bytes $impl_address $proxy_address"
}

# ============================================================================
# EXTRACT MODE
# ============================================================================

do_extract() {
  local contract="BaoFactory"
  local srcFile="src/${contract}.sol"
  local artifact="$PROJECT_ROOT/out/${contract}.sol/${contract}.json"
  log "BaoFactory Bytecode Extraction"
  log "=============================="
  local salt="$DEFAULT_SALT"
  echo "    Source:         $srcFile"
  echo "    Build artifact: $artifact"
  echo "    Output:         $BYTECODE_SOL"
  echo "    Salt:           $salt"
  echo ""

  log "Compiling..."
  rm -f ${artifact}
  forge build --force ${srcFile} 2>&1 | sed 's/^/    /'
  if [[ ! -f "$artifact" ]]; then
    error "Compilation failed - artifact not found"
  fi

  echo ""
  log "Capturing gas cost and deploy size..."
  forge test --mc BaoFactorySmokeTest --isolate --gas-report | sed -n '/^╭----------/,/^╰----------/p' | tee "$GAS_TXT" | sed 's/^/    /'
  log "Gas report saved to $GAS_TXT"

  # Extract bytecode
  local bytecode
  bytecode=$(jq -r '.bytecode.object' "$artifact")
  if [[ -z "$bytecode" || "$bytecode" == "null" ]]; then
    error "Failed to extract bytecode from artifact"
  fi

  local bytecode_hex="${bytecode#0x}"
  local bytecode_hash
  bytecode_hash=$(cast keccak "$bytecode")

  echo ""
  log "Extracted bytecode:"
  echo "    Size: $((${#bytecode_hex} / 2)) bytes"
  echo "    Hash: $bytecode_hash"

  # Compute addresses for default salt
  local addr_info
  addr_info=$(get_addresses_for_salt "$salt" "$bytecode")
  local salt_bytes impl_address proxy_address
  read -r salt_bytes impl_address proxy_address <<<"$addr_info"

  # Generate BaoFactoryBytecode.sol
  mkdir -p "$(dirname "$BYTECODE_SOL")"
  cat >"$BYTECODE_SOL" <<SOLEOF
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.28 <0.9.0;

// ============================================================================
// AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
// ============================================================================
// Compiler: solc $SOLC_VERSION
// EVM version: $EVM_VERSION
// Optimizer: true (runs: $OPTIMIZER_RUNS, via_ir: true)
// Metadata: none (bytecode_hash = "none", cbor_metadata = false)
// ============================================================================
//
// This file contains the captured creation code for BaoFactory.
// To regenerate: ./script/bao-factory --extract
//
// For deployment logic, see BaoFactoryDeployLib.sol
// For Foundry test utilities, see BaoFactoryFoundryLib.sol
// ============================================================================

/// @title BaoFactoryBytecode
/// @author Bao Finance
/// @notice Captured creation code and addresses for deterministic BaoFactory deployment
/// @dev Generated bytecode ensures consistent addresses regardless of compiler changes
library BaoFactoryBytecode {
    /// @dev Nick's Factory address (same on all EVM chains)
    address internal constant NICKS_FACTORY = 0x4e59b44847b379578588920cA78FbF26c0B4956C;

    /// @dev Nick's Factory bytecode (for deployment to fresh chains/test environments)
    bytes internal constant NICKS_FACTORY_BYTECODE =
        hex"7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe03601600081602082378035828234f58015156039578182fd5b8082525050506014600cf3";

    /// @dev BaoFactory salt string
    string internal constant SALT = "$DEFAULT_SALT";

    /// @dev BaoFactory owner (Harbor multisig)
    address internal constant OWNER = $OWNER;

    /// @dev BaoFactory creation code
    bytes internal constant CREATION_CODE =
        hex"$bytecode_hex";

    /// @dev keccak256 of CREATION_CODE
    bytes32 internal constant CREATION_CODE_HASH = $bytecode_hash;

    /// @dev Predicted implementation address (depends on SALT and CREATION_CODE_HASH)
    address internal constant PREDICTED_IMPLEMENTATION = $impl_address;

    /// @dev Predicted proxy address (depends on PREDICTED_IMPLEMENTATION)
    address internal constant PREDICTED_PROXY = $proxy_address;
}
SOLEOF

  echo ""
  log "Generated $BYTECODE_SOL"
  log "Predicted addresses for salt '$DEFAULT_SALT':"
  echo "    Implementation: $impl_address"
  echo "    Proxy:          $proxy_address"
  echo ""
  echo "Done!"
}
# ============================================================================

do_deploy() {
  local network="$1"
  local salt="$2"
  local account="$3"
  local dry_run="$4"

  log "BaoFactory Deployment"
  log "====================="

  # Check build directory exists
  if [[ ! -d "$PROJECT_ROOT/out" ]]; then
    error "Build artifacts not found. Run 'bao-factory --extract' first."
  fi

  # Get saved bytecode
  local bytecode
  bytecode=$(get_saved_bytecode)
  local bytecode_hash
  bytecode_hash=$(cast keccak "$bytecode")

  echo "    Bytecode hash: $bytecode_hash"
  echo "    Bytecode size: $(((${#bytecode} - 2) / 2)) bytes"
  echo ""

  # Compute addresses for this salt
  local addr_info
  addr_info=$(get_addresses_for_salt "$salt" "$bytecode")
  local salt_bytes impl_address proxy_address
  read -r salt_bytes impl_address proxy_address <<<"$addr_info"

  echo "    Salt:           $salt"
  echo "    Salt bytes32:   0x$salt_bytes"
  echo "    Network:        $network"
  echo "    Owner:          $OWNER"
  echo ""

  log "Predicted addresses:"
  echo "    Implementation: $impl_address"
  echo "    Proxy:          $proxy_address"
  echo ""

  # Set up wallet
  local wallet_args=""
  if [[ "$network" == "local" ]]; then
    if [[ -n "$account" ]]; then
      wallet_args="--account $account"
    else
      wallet_args="--private-key $ANVIL_PRIVATE_KEY"
    fi
  else
    if [[ -z "$account" ]]; then
      error "--account is required for non-local networks"
    fi
    wallet_args="--account $account"
  fi

  # Check if already deployed
  local impl_code
  impl_code=$(cast code "$impl_address" --rpc-url "$network" 2>/dev/null || echo "0x")
  if [[ "$impl_code" != "0x" && "$impl_code" != "" ]]; then
    error "Already deployed at $impl_address. Use --verify to verify on Etherscan."
  fi

  if [[ "$dry_run" == "true" ]]; then
    log "DRY RUN - would deploy to:"
    echo "    Implementation: $impl_address"
    echo "    Proxy:          $proxy_address"
    exit 0
  fi

  # Deploy via Nick's Factory
  log "Deploying via Nick's Factory..."

  local deploy_data="0x${salt_bytes}${bytecode#0x}"
  local tx_hash
  tx_hash=$(cast send --json --rpc-url "$network" $wallet_args \
    "$NICKS_FACTORY" "$deploy_data" | jq -r '.transactionHash')

  if [[ -z "$tx_hash" || "$tx_hash" == "null" ]]; then
    error "Deployment transaction failed"
  fi

  log "Transaction submitted: $tx_hash"

  log "Waiting for confirmation..."
  cast receipt --rpc-url "$network" "$tx_hash" >/dev/null

  # Verify deployment
  impl_code=$(cast code "$impl_address" --rpc-url "$network")
  if [[ "$impl_code" == "0x" || "$impl_code" == "" ]]; then
    error "Implementation deployment failed - no code at $impl_address"
  fi

  local proxy_code
  proxy_code=$(cast code "$proxy_address" --rpc-url "$network")
  if [[ "$proxy_code" == "0x" || "$proxy_code" == "" ]]; then
    error "Proxy deployment failed - no code at $proxy_address"
  fi

  log "Deployment successful!"
  echo ""
  echo "BaoFactory deployed:"
  echo "    Proxy (use this):     $proxy_address"
  echo "    Implementation:       $impl_address"
  echo "    Owner:                $OWNER"
  echo "    Transaction:          $tx_hash"
}

# ============================================================================
# PREDICT MODE
# ============================================================================

do_predict() {
  local salt="$1"

  log "BaoFactory Address Prediction"
  log "============================="

  # Get saved bytecode
  local bytecode
  bytecode=$(get_saved_bytecode)

  # Compute addresses
  local addr_info
  addr_info=$(get_addresses_for_salt "$salt" "$bytecode")
  local salt_bytes impl_address proxy_address
  read -r salt_bytes impl_address proxy_address <<<"$addr_info"

  echo "    Salt:           $salt"
  echo "    Salt (bytes32): 0x$salt_bytes"
  echo ""
  log "Predicted addresses:"
  echo "    Implementation: $impl_address"
  echo "    Proxy:          $proxy_address"
}

# ============================================================================
# VERIFY MODE
# ============================================================================

do_verify() {
  local network="$1"
  local salt="$2"

  log "BaoFactory Verification"
  log "======================="

  # Check build directory exists
  if [[ ! -d "$PROJECT_ROOT/out" ]]; then
    error "Build artifacts not found. Run 'bao-factory --extract' first."
  fi

  # Check ETHERSCAN_KEY
  if [[ -z "${ETHERSCAN_KEY:-}" ]]; then
    error "ETHERSCAN_KEY environment variable required"
  fi

  # Get saved bytecode
  local bytecode
  bytecode=$(get_saved_bytecode)

  # Compute addresses for this salt
  local addr_info
  addr_info=$(get_addresses_for_salt "$salt" "$bytecode")
  local salt_bytes impl_address proxy_address
  read -r salt_bytes impl_address proxy_address <<<"$addr_info"

  echo "    Salt:           $salt"
  echo "    Network:        $network"
  echo "    Implementation: $impl_address"
  echo "    Proxy:          $proxy_address"
  echo ""

  # Check if deployed
  local impl_code
  impl_code=$(cast code "$impl_address" --rpc-url "$network" 2>/dev/null || echo "0x")
  if [[ "$impl_code" == "0x" || "$impl_code" == "" ]]; then
    error "Contract not deployed at $impl_address. Run --deploy first."
  fi

  log "Contract found on-chain, verifying..."

  local chain_id
  chain_id=$(cast chain-id --rpc-url "$network")

  log "Verifying implementation at $impl_address..."
  forge verify-contract \
    --chain-id "$chain_id" \
    --etherscan-api-key "$ETHERSCAN_KEY" \
    --watch \
    --root "$PROJECT_ROOT" \
    --compiler-version "$SOLC_VERSION" \
    --optimizer-runs "$OPTIMIZER_RUNS" \
    --via-ir \
    "$impl_address" \
    "src/BaoFactory.sol:BaoFactory" ||
    echo "Warning: Verification failed (may already be verified)"

  log "Note: Proxy at $proxy_address is a minimal ERC1967 proxy (61 bytes)"
  log "      It uses the implementation at $impl_address"
  echo ""
  log "Done!"
}

# ============================================================================
# MAIN
# ============================================================================

# Parse arguments
MODE=""
NETWORK=""
SALT="$DEFAULT_SALT"
ACCOUNT=""
DRY_RUN=false

while [[ $# -gt 0 ]]; do
  case "$1" in
    --extract)
      MODE="extract"
      shift
      ;;
    --predict)
      MODE="predict"
      shift
      ;;
    --deploy)
      MODE="deploy"
      shift
      ;;
    --verify)
      MODE="verify"
      shift
      ;;
    --predict)
      MODE="predict"
      shift
      ;;
    --network)
      NETWORK="$2"
      shift 2
      ;;
    --salt)
      SALT="$2"
      shift 2
      ;;
    --account)
      ACCOUNT="$2"
      shift 2
      ;;
    --dry-run)
      DRY_RUN=true
      shift
      ;;
    -h | --help)
      usage 0
      ;;
    *)
      error "Unknown option: $1"
      ;;
  esac
done

# Validate mode
if [[ -z "$MODE" ]]; then
  error "Must specify --extract, --deploy, or --verify"
fi

cd "$PROJECT_ROOT"

case "$MODE" in
  extract)
    if [[ "$SALT" != "$DEFAULT_SALT" ]]; then
      error "--salt cannot be used with --extract. Use '--predict --salt <value>' to inspect custom salts."
    fi
    do_extract
    ;;
  deploy)
    if [[ -z "$NETWORK" ]]; then
      error "--network is required for --deploy"
    fi
    do_deploy "$NETWORK" "$SALT" "$ACCOUNT" "$DRY_RUN"
    ;;
  verify)
    if [[ -z "$NETWORK" ]]; then
      error "--network is required for --verify"
    fi
    do_verify "$NETWORK" "$SALT"
    ;;
  predict)
    do_predict "$SALT"
    ;;
esac
