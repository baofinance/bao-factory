# bao-factory

Canonical Bao Factory contracts plus deterministic deployment helpers. We keep the factory in this dedicated subtree because its build needs to be _boringly consistent_: the same compiler flags, the same bytecode blob, and therefore the same deterministic deployment addresses across every downstream repo. The tree is vendored into `bao-base`, so consumers get updates via git rather than npm crates or copy/paste.

## Source Layout

- `src/BaoFactory.sol` – upgradeable factory implementation with the production owner baked in.
- `src/BaoFactoryBytecode.sol` – captured creation code, Nick's Factory constants, and the predicted deterministic addresses.
- `src/BaoFactoryDeployment.sol` – shared helper that downstream repos import to "ensure" a BaoFactory exists (production bytecode or current build).
- `src/BaoFactoryDeployLib.sol` / `src/BaoFactoryFoundryLib.sol` – lower-level deploy helpers plus Forge-specific utilities (e.g., `vm.etch`).
- `test/` – unit tests that cover the deterministic deployment, operator management, and upgrade flows.

## Deploying from Other Repos

Import the helper and call the mode that matches your use case:

```solidity
import {BaoFactoryDeployment} from "@bao-factory/BaoFactoryDeployment.sol";

contract MyScript {
    function _ensureBaoFactory() internal returns (address baoFactory) {
        // Production (captured bytecode + owner verification)
        baoFactory = BaoFactoryDeployment.ensureBaoFactoryProduction();
    }
}
```

For tests that must track local edits to `BaoFactory.sol`, call `ensureBaoFactoryCurrentBuild()` instead. Both functions verify the proxy runtime code hash and enforce that the owner matches the embedded production multisig, so downstream code does not need to duplicate those checks.

The deployed proxy uses UUPS upgradeability. Shipping a new BaoFactory variant usually just means rolling out a new implementation and having the production owner upgrade the existing proxy to the fresh logic. Downstream repos should assume the address stays constant while the logic can evolve via upgrades.

Use `predictBaoFactoryAddress()` / `predictBaoFactoryImplementation()` if you only need the deterministic addresses without deploying anything. Pass a custom salt + creation-code hash to the overloaded versions when experimenting with alternative variants.

## Keeping the Bytecode Current

Treat `src/BaoFactory.sol` as nearly frozen. Only touch it when you intentionally want to mint a _new_ BaoFactory release, because any change forces every deployment pipeline to update bytecode snapshots.

1. Make the intentional change in `src/BaoFactory.sol` (and document _why_ in the commit message—future maintainers need that context).
2. Run the extractor to regenerate the captured creation code and metadata. This produces the implementation bytecode that existing proxies will upgrade into, so keep the toolchain pinned and deterministic:

   ```bash
   cd lib/bao-factory
   ./script/bao-factory --extract
   ```

   This overwrites `src/BaoFactoryBytecode.sol` with the new creation code, hashes, and predicted addresses.
3. Commit both the Solidity change and the regenerated bytecode so downstream repos stay deterministic.

## Testing

Inside `lib/bao-factory` run:

```bash
yarn test           # convenience wrapper that invokes forge test
```

Downstream projects should rely on these tests rather than duplicating BaoFactory harnesses. When integration tests need a deployed factory on a fresh chain, use `BaoFactoryFoundryLib.deployForTesting()` (which will `vm.etch` Nick's Factory if required) and then configure operators through the helper.
